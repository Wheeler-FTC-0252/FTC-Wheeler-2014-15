#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          one,           tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          two,           tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    sarm,                 tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    bottle,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NMOTORS 2
#define NLEVELS 3 // sizeof(arm_levels)/4
#define maxspeed 30 //used for arm motors
#define sec_arm_speed 4 //linked to arm servo speed
int arm_levels[NLEVELS]={0,15,59};
int servo_levels[NLEVELS]={0,15,59};

#include "JoystickDriver.c"

int transfer_J_To_M(int joy,float slope,int dead) // joy = joy input, dead = dead band, slope = max motor output/max joy input - in this case 100/128
{
	int y;
	if (abs(joy)<dead)
		y=0;
	else
		y=slope*((float)joy-(float)dead*sgn(joy));

	return y;
}

void init(){
	//ENCODER SETUPS
	nMotorEncoder[arm]=0;

	//SERVO SETUPS
	//	SERVO SPEEDS
	servoChangeRate[sarm]=sec_arm_speed;
	servoChangeRate[bottle]=sec_arm_speed;
}

void movement(int tophat, int * roundup, int * rounddown){
	if (nMotorEncoder[arm]<arm_levels[1]){//lower than 2nd lowest
		*roundup=1;
		*rounddown=0;
	}
	else if (nMotorEncoder[arm]>arm_levels[NLEVELS-2]){//higher then 2nd highest
		*roundup=NLEVELS-1;
		*rounddown=NLEVELS-2;
	}
	else{//somewhere inbetween 2nd low and 2nd high
		for (int ii=0; ii<NLEVELS-1; )
		{
			*roundup=ii+1;
			*rounddown=ii;
			if (arm_levels[*rounddown]<nMotorEncoderTarget[arm] && nMotorEncoderTarget[arm]<arm_levels[*rounddown])
			{
				break;
			}
		}
	}
	writeDebugStreamLine("%d",nMotorEncoder[arm]);
	switch (tophat){
	case 0://up
			motor[arm]=maxspeed;//in this order so it doesnt break when going up
			nMotorEncoderTarget[arm]=arm_levels[*roundup];
			while (nMotorRunState[arm]!=runStateHoldPosition){//wait for that movement
			}
			servo[sarm]=servo_levels[*roundup];
			servo[bottle]=servo_levels[*roundup];
			writeDebugStreamLine("yolo:%d,,%d",nMotorEncoder[arm],servo[sarm]);
		break;
	case 4://down
			servo[sarm]=servo_levels[*rounddown];//in this order so it doesnt break when going down
			while (servo[sarm]+5>servo_levels[*rounddown] || servo[sarm]-5<servo_levels[*rounddown]){//CHECK CHECK CHECK, NOT SURE ABOUT THIS STUUF
				servo[bottle]=servo[sarm];//a way to keep them in sync
			}
			motor[arm]=maxspeed;
			nMotorEncoderTarget[arm]=arm_levels[*rounddown];
		break;
	}
}

task main()
{
	clearDebugStream();
	int joy_1x1;
	int joy_1x2;
	int joy_1y1;
	int joy_1y2;
	int tophat;
	float joyslope = (100./128.)*.5;
	//int motorBoundsHi[NMOTORS]={1000,500};
	//int motorBoundsLo[NMOTORS]={10,5};
	int dband=15;
	int tophat_old=-1;
	//int wasmanual=0;//1 is yes 0 is no
	int rounddown=0;//the two values to use when
	int roundup=0;

	nMotorEncoder[one]=0;//must be on the ground
	nMotorEncoder[two]=0;//must be on ground
	writeDebugStreamLine("MAKE SURE ROBOT IS ON GROUND");
	wait10Msec(200);

	init();//run my initiation function
	while (true)
	{
		//wait10Msec(100);
		getJoystickSettings(joystick);
		joy_1y1=transfer_J_To_M(joystick.joy1_y1, joyslope, dband);
		joy_1y2=transfer_J_To_M(joystick.joy1_y2, joyslope, dband);
		joy_1x1=transfer_J_To_M(joystick.joy1_x1, joyslope, dband);
		joy_1x2=transfer_J_To_M(joystick.joy1_x2, joyslope, dband);
		tophat=joystick.joy1_TopHat;

		//   writeDebugStreamLine("one: %d, two: %d", nMotorEncoder[one], nMotorEncoder[two]);
		//writeDebugStreamLine("two: %d", nMotorEncoder[two]);

		if (joy_1y2!=0)//teesting for joy being used
		{
			if (
				(nMotorEncoder[arm] < arm_levels[NLEVELS-1] && joy_1y2 > 0)
			||
			(nMotorEncoder[arm] > arm_levels[0] && joy_1y2 < 0)
			){
				nMotorEncoderTarget[arm]=0;
				motor[arm]=joy_1y2;
			}
			else{
				motor[arm]=0;
			}
		}
		else if (tophat!=tophat_old){
			writeDebugStreamLine("that has changed");
			movement(tophat, &roundup, &rounddown);
		}
		tophat_old=tophat;
	}
}
