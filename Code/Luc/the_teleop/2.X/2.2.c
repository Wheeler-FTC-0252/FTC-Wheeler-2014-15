#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          one,           tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          two,           tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    sarm,                 tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    bottle,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NMOTORS 2
#define NLEVELS 3 // sizeof(arm_levels)/4
#define maxspeed 30 //used for arm motors

int arm_levels[NLEVELS]={0,15,59};
int servo_levels[NLEVELS]={0,15,59};

#include "JoystickDriver.c"

int transfer_J_To_M(int joy,float slope,int dead) // joy = joy input, dead = dead band, slope = max motor output/max joy input - in this case 100/128
{
	int y;
	if (abs(joy)<dead)
		y=0;
	else
		y=slope*((float)joy-(float)dead*sgn(joy));

	return y;
}

void init(){
	//ENCODER SETUPS
	nMotorEncoder[arm]=0;

	//SERVO SETUPS
	//	SERVO SPEEDS
	//servo[]
}

void movement(int tophat, int * roundup, int * rounddown){
	if (nMotorEncoder[arm]<arm_levels[1]){//lower than 2nd lowest
		*roundup=1;
		*rounddown=0;
	}
	else if (nMotorEncoder>arm_levels[NLEVELS-2]){//higher then 2nd highest
		*roundup=NLEVELS-1;
		*rounddown=NLEVELS-2;
	}
	else{//somewhere inbetween 2nd low and 2nd high
		for (int ii=0; ii<NLEVELS-1; )
		{
			*roundup=ii+1;
			*rounddown=ii;
			if (arm_levels[*rounddown]<nMotorEncoderTarget[arm] && nMotorEncoderTarget[arm]<arm_levels[*rounddown])
			{
				break;
			}
		}
	}

	switch (tophat){
	case 0://up
		if (roundup==1){//make sure to move the main arm first so robot is not destroyed
			motor[arm]=maxspeed;
			nMotorEncoderTarget[arm]=arm_levels[roundup];
			while (nMotorRunState[arm]!=runStateHoldPosition){//wait for that movement
			}
			servo[sarm]=servo_levels[roundup];
			servo[bottle]=servo_levels[roundup];
		}/*
		else{
		motor[arm]=maxspeed;
		nMotorEncoderTarget[arm]=arm_levels[roundup];
		servo[sarm]=servo_levels[roundup];
		servo[bottle]=servo_levels[roundup];
		while (nMotorRunState[arm]!=runStateHoldPosition){
		//want to do this to stop screw ups, the machine can take its time
		}
		*/
		//141120 REMOVED-- II dont think /\ is needed
	break;
case 4://down
	if (rounddown==0){//fold servo arm first so it doesn't damage itself
		servo[sarm]=servo_levels[rounddown];
		while (servo[sarm]+5>servo_levels[rounddown] || servo[sarm]-5<servo_levels[rounddown]){//CHECK CHECK CHECK, NOT SURE ABOUT THIS STUUF
			servo[bottle]=servo[sarm];//a way to keep them in sync
		}
		motor[arm]=maxspeed;
		nMotorEncoderTarget[arm]=arm_levels[rounddown];
	}
	break;
}
}

task main()
{
clearDebugStream();
int joy_1x1;
int joy_1x2;
int joy_1y1;
int joy_1y2;
int tophat;
float joyslope = (100./128.)*.5;
//int motorBoundsHi[NMOTORS]={1000,500};
//int motorBoundsLo[NMOTORS]={10,5};
int dband=15;
int tophat_old=0;
//int wasmanual=0;//1 is yes 0 is no
int rounddown=0;//the two values to use when
int roundup=0;

nMotorEncoder[one]=0;//must be on the ground
nMotorEncoder[two]=0;//must be on ground
writeDebugStreamLine("MAKE SURE ROBOT IS ON GROUND");
wait10Msec(200);

init();
while (true)
{
	//wait10Msec(100);
	getJoystickSettings(joystick);
	joy_1y1=transfer_J_To_M(joystick.joy1_y1, joyslope, dband);
	joy_1y2=transfer_J_To_M(joystick.joy1_y2, joyslope, dband);
	joy_1x1=transfer_J_To_M(joystick.joy1_x1, joyslope, dband);
	joy_1x2=transfer_J_To_M(joystick.joy1_x2, joyslope, dband);
	tophat=joystick.joy1_TopHat;

	writeDebugStreamLine("one: %d, two: %d", nMotorEncoder[one], nMotorEncoder[two]);
	//writeDebugStreamLine("two: %d", nMotorEncoder[two]);

	if (joy_1y2!=0)
	{
		if (
			(nMotorEncoder[arm] < arm_levels[NLEVELS-1] && joy_1y2 > 0)
		||
		(nMotorEncoder[arm] > arm_levels[0] && joy_1y2 < 0)
		){
			nMotorEncoderTarget[arm]=0;
			motor[arm]=joy_1y2;
		}
		else
			motor[arm]=0;
	}

	if (tophat!=tophat_old)
	{
		for (int ii=0;ii<sizeof(arm_levels)/4;ii++)
		{
			rounddown=ii;
			roundup=ii+1;
			if ()
				if (arm_levels[ii] < nMotorEncoder[arm] < arm_levels[ii+1])
			{
				break;
			}
		}

		switch (tophat){
		case 0:
			motor[arm]=maxspeed;
			nMotorEncoderTarget[arm]=arm_levels[roundup];
			writeDebugStreamLine("U wrote up   %6d", nMotorEncoder[arm]);
			break;
		case 4:
			motor[arm]=-1*maxspeed;
			nMotorEncoderTarget[arm]=arm_levels[rounddown];
			break;
			writeDebugStreamLine("U wrote down %6d", nMotorEncoder[arm]);
		default:
			motor[arm]=0;
			writeDebugStreamLine("DEFAULT      %6d", nMotorEncoder[arm]);
			break;
		}
	}
	tophat_old=tophat;
}
}
