#pragma config(Sensor, S1,     bSonar,         sensorSONAR)
#pragma config(Sensor, S2,     fSonar,         sensorSONAR)
#pragma config(Sensor, S3,     rSonar,         sensorSONAR)
#pragma config(Sensor, S4,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void init(){
	//ENCODERS//
	nMotorEncoder[left]=0;
	nMotorEncoder[right]=0;

	//SOUND//
	nVolume = 2;
	bPlaySounds = true;
}

task main()
{
//	int compOffSet=SensorValue[compass];
//	int rotateAmount=20;//rotate amount in degrees for second part
//	int rotateTarget=compOffSet;//for 2nd half
	int rotateTarget;

//	int rotateSpeed=50;

	int fieldlength=176;//cm
	int failsafedis=600*(fieldlength/19);//600 on the motor encoder results in moving 19 cm
	int dropdis=10;//cm
	int walldis=20;//cm
	int speed=50;
	float delta;

	//	float deltaGain = 2.5;
	//	float deltaPow = 2.; // Power of index for delta

	float deltaGain = 1.;
	float deltaPow = 1.; // Power of index for delta

	int sonarF,sonarR; // Sonar values inside loop
	init();

	//START

	motor[left]=speed;
	motor[right]=speed;

	while (nMotorEncoder[left]<failsafedis || nMotorEncoder[right]<failsafedis){

		sonarF = SensorValue[fSonar];
		sonarR = SensorValue[rSonar];

		nxtDisplayCenteredTextLine(2,"MotL: %3d",motor[left]);
		nxtDisplayCenteredTextLine(3,"MotR: %3d",motor[right]);
		nxtDisplayCenteredTextLine(4,"SonF: %3d cm",sonarF);
		nxtDisplayCenteredTextLine(5,"SonR: %3d cm",sonarR);

		if (sonarF<dropdis){
			break;
		}

		if ( sonarR>254 || abs(sonarR-walldis)<1 ){
			motor[left]=speed;
			motor[right]=speed;
		}
		else {
			// motor[left]=speed;

			if(0)
			{
				// Fractional miss
				delta = deltaGain
				* sgn( (float)SensorValue[rSonar]/(float)walldis -1 )
				* pow( abs((float)SensorValue[rSonar]/(float)walldis-1) , deltaPow);
				// Bounds check since we don't want robot to stop, or reverse a side
				if(abs(delta)>0.9) delta= sgn(delta)*0.9;
				nxtDisplayCenteredTextLine(6,"delta:%5.1f%%",100.*delta);
				writeDebugStreamLine("delta:%f",delta);
				motor[left]=speed*(1+delta);
				motor[right]=speed*(1-delta);
			}
			else
			{
				// Fractional miss
				delta = (float)SensorValue[rSonar]/(float)walldis-1;
				// Bounds check since we don't want robot to stop, or reverse a side
				if(abs(delta)>0.9) delta= sgn(delta)*0.9;
				nxtDisplayCenteredTextLine(6,"delta:%5.1f%%",100.*delta);
				writeDebugStreamLine("delta:%f",delta);
				motor[left]=speed*(1+delta);
				motor[right]=speed*1/(1+delta);
			}
		}
	}
	motor[left]=0;
	motor[right]=0;

	playSound(soundBeepBeep); while (bSoundActive){}

	// ROTATE TO NEW BEARING ON SPOT

	rotateTarget=153;
	speed = -50; // Going backwards
	while(true)
		{
				delta = ( (float)SensorValue[compass] - (float)rotateTarget );
				// Make it so that +angle is heading to right of target (so steer left)
				//  and -ve angle is heading to left of target (so steer right)
				delta = (delta+180 % 360)-180; // Stops problems when close to north
				// always get and answer between -180 and +180 degrees for correction

				delta = delta/30.; // so 100 degrees would be 100% correction

				// Bounds check since we don't want robot to go too fast when trying to correct major errors
				if(abs(delta)>0.9) delta= sgn(delta)*0.9;

				nxtDisplayCenteredTextLine(6,"delta:%5.1f%%",100.*delta);
				// writeDebugStreamLine("Rotate delta:%f",delta);

				writeDebugStreamLine("Angle sensor:%5d , target %5d ,  delta %5.1f"
				  ,SensorValue[compass]
				  , rotateTarget
				  , delta);

				// Set up for driving backwards
				motor[left]=speed*(delta);
				motor[right]=speed*(-delta);

				if(abs(delta)<0.05) break;
}
	motor[left]=0;
	motor[right]=0;


		playSound(soundBeepBeep);
		while (bSoundActive){}

	// THEN DRIVE ON SIMILAR BEARING UNTIL HITS WALL

		rotateTarget=rotateTarget-20;


	clearTimer(T1);
	while(true)
		{
				delta = ( SensorValue[compass] - (float)rotateTarget );
				// Make it so that +angle is heading to right of target (so steer left)
				//  and -ve angle is heading to left of target (so steer right)

				delta = (delta+180 % 360)-180; // Stops problems when close to north
				// always get and answer between -180 and +180 degrees for correction

				delta = delta/30; // so 100 degrees would be 100% correction

				// Bounds check since we don't want robot to go too fast when trying to correct major errors
				if(abs(delta)>0.9) delta= sgn(delta)*0.9;

				//nxtDisplayCenteredTextLine(6,"delta:%5.1f%%",100.*delta);
				//writeDebugStreamLine("delta:%f",delta);

				/*
				writeDebugStreamLine("Angle sensor:%5d , target %5d ,  delta %5.1f"
				  ,SensorValue[compass]
				  , rotateTarget
				  , delta);
				*/

				// driving backwards
				motor[left]=speed*(1+delta);
				motor[right]=speed*(1-delta);

				writeDebugStreamLine("Distance back:%5d , right %5d , front %5d"
				  ,SensorValue[bSonar]
				  ,SensorValue[rSonar]
				  ,SensorValue[fSonar]
					);

					if (time1[T1] > 3000)
					{
				if(SensorValue[bSonar]<40)break;
				if(SensorValue[rSonar]<32)break;
			}
}
	motor[left]=0;
	motor[right]=0;

	playSound(soundBeepBeep); while (bSoundActive){}


	// TURN AT END

		rotateTarget=193;
	speed = -50; // Going backwards
	while(true)
		{
				delta = ( (float)SensorValue[compass] - (float)rotateTarget );
				// Make it so that +angle is heading to right of target (so steer left)
				//  and -ve angle is heading to left of target (so steer right)
				delta = (delta+180 % 360)-180; // Stops problems when close to north
				// always get and answer between -180 and +180 degrees for correction

				delta = delta/30.; // so 100 degrees would be 100% correction

				// Bounds check since we don't want robot to go too fast when trying to correct major errors
				if(abs(delta)>0.9) delta= sgn(delta)*0.9;

				nxtDisplayCenteredTextLine(6,"delta:%5.1f%%",100.*delta);
				// writeDebugStreamLine("Rotate delta:%f",delta);

				writeDebugStreamLine("Angle sensor:%5d , target %5d ,  delta %5.1f"
				  ,SensorValue[compass]
				  , rotateTarget
				  , delta);

				// Set up for driving backwards
				motor[left]=speed*(delta);
				motor[right]=speed*(-delta);

				if(abs(delta)<0.05) break;
}
	motor[left]=0;
	motor[right]=0;


	playSound(soundBeepBeep); while (bSoundActive){}

	/*
	rotateTarget=SensorValue[compass]+rotateAmount;
	if (rotateTarget>360){
		rotateTarget=rotateTarget-360;
	}

	motor[left]=speed;
	motor[right]=-speed;

	while (SensorValue[compass]!=rotateTarget){
		nxtDisplayCenteredTextLine(2,"MotL: %d",motor[left]);
		nxtDisplayCenteredTextLine(3,"MotR: %d",motor[right]);
		nxtDisplayCenteredTextLine(4,"Comp: %d ",SensorValue[compass]);
		nxtDisplayCenteredTextLine(5,"t: %d",rotateTarget);
	}

	motor[left]=-speed;
	motor[right]=-speed;

	while (SensorValue[bSonar]>30){}
	motor[left]=0;
	motor[right]=0;

*/

	playSound(soundBeepBeep);
	while (bSoundActive){}

	}
