#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     arm,           tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     leftSpliced,   tmotorTetrix, PIDControl, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     left,          tmotorTetrix, PIDControl, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     rightSpliced,  tmotorTetrix, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     right,         tmotorTetrix, PIDControl, reversed, driveRight, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    spin1,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    spin2,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    catchServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//using updated versions of "wallfollow2.0.c" and "compassfollow2.0.c" -- has no motor limit

#include "wallfollow2.0.c"
#include "compassfollow2.0.c"
#include "hitechnic-sensormux.h"//put this before other third party ones

void init(){
	//ENCODERS//
	nMotorEncoder[left]=0;
	nMotorEncoder[right]=0;

	//SERVO//
	servoChangeRate[door]=2;

	//SOUND//
	nVolume = 2;
	bPlaySounds = true;
}

task main()
{
	//	int compOffSet=SensorValue[compass];
	//	int rotateAmount=20;//rotate amount in degrees for second part
	//	int rotateTarget=compOffSet;//for 2nd half
	int rotateTarget;

	//	int rotateSpeed=50;

	int fieldlength=176;//cm
	int failsafedis=-25600;//600*(fieldlength/19);//600 on the motor encoder results in moving 19 cm
	int dropdis=9;//cm
	int walldis=20;//cm
	int speed=-30;//for wall follow
	int armSpeed=10;
	int rotateSpeed;
	bool sonarStop;
	int timeSensorEnable;
	int stopdis;
	tMotor leftSide[2]={leftSpliced, left};
	tMotor rightSide[2]={rightSpliced, right};
	tMUXSensor lSonar=msensor_S4_2;
	tMUXSensor fSonar=msensor_S4_4;
	tMUXSensor bSonar=msensor_S4_3;

	init();
	servo[door]=10;
	//START
	servo[catchServo]=100;//catch up
	wallfollow(walldis,speed,dropdis,failsafedis,bSonar,lSonar,leftSide,rightSide,true,true);
	servo[catchServo]=0;//catch down
	wait1Msec(1000);

	servo[door]=150;
	wait1Msec(300);
	servo[spin1]=255;
	servo[spin2]=0;
	wait1Msec(1000);

	motor[arm]=0;
	nMotorEncoderTarget[arm]=4550;
	motor[arm]=armSpeed;
	servo[spin1]=0;
	servo[spin2]=255;
	while (nMotorRunState[arm]!=runStateIdle){
		if (nMotorEncoder[arm]>500){
			servo[spin1]=127;
			servo[spin2]=127;
		}
	}
	motor[arm]=0;


	// ROTATE TO NEW BEARING ON SPOT
	rotateTarget=SensorValue[compass]+20;
	speed = 50;
	rotateSpeed=50;
	sonarStop = false;
	timeSensorEnable=300;//10 ms increments
	stopdis=50;

	compassfollow(speed,rotateSpeed,rotateTarget,timeSensorEnable,sonarStop,stopdis,compass,bSonar,rSonar,leftSide,rightSide,true,true);

	/*
	// THEN DRIVE ON SIMILAR BEARING UNTIL HITS WALL

	rotateTarget=rotateTarget-20;
	speed = 50;
	rotateSpeed=0;
	sonarStop = true;
	timeSensorEnable=300;//10 ms increments
	stopdis=50;

	compassfollow(speed,rotateSpeed,rotateTarget,timeSensorEnable,sonarStop,stopdis,compass,bSonar,rSonar,leftSide,rightSide,leftSideMUX,rightSideMUX);
	MSMMotor(mmotor_S1_1,0);
	MSMMotor(mmotor_S1_2,0);
	*/
}
