#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          one,           tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          two,           tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NMOTORS 2
#define NLEVELS sizeof(arm_levels)/4

#include "JoystickDriver.c"

int transfer_J_To_M(int joy,float slope,int dead) // joy = joy input, dead = dead band, slope = max motor output/max joy input - in this case 100/128
{
	int y;
	if (abs(joy)<dead)
		y=0;
	else
		y=slope*((float)joy-(float)dead*sgn(joy));

	return y;
}


task main()
{
	clearDebugStream();
	int joy_1x1;
	int joy_1x2;
	int joy_1y1;
	int joy_1y2;
	int tophat;
	float joyslope = (100./128.)*.5;
	//int motorBoundsHi[NMOTORS]={1000,500};
	//int motorBoundsLo[NMOTORS]={10,5};
	int arm_levels[3]={0,15,59};
	int servo_levels[3]={0,15,59};
	int dband=15;
	int tophat_old=0;
	//int wasmanual=0;//1 is yes 0 is no
	int rounddown=0;//the two values to use when
	int roundup=0;
	int maxspeed=30;//speed for motors when tophat is used

	nMotorEncoder[one]=0;//must be on the ground
	nMotorEncoder[two]=0;//must be on ground
	writeDebugStreamLine("MAKE SURE ROBOT IS ON GROUND");
	wait10Msec(200);

	while (true)
	{
		//wait10Msec(100);
		getJoystickSettings(joystick);
		joy_1y1=transfer_J_To_M(joystick.joy1_y1, joyslope, dband);
		joy_1y2=transfer_J_To_M(joystick.joy1_y2, joyslope, dband);
		joy_1x1=transfer_J_To_M(joystick.joy1_x1, joyslope, dband);
		joy_1x2=transfer_J_To_M(joystick.joy1_x2, joyslope, dband);
		tophat=joystick.joy1_TopHat;

		writeDebugStreamLine("one: %d, two: %d", nMotorEncoder[one], nMotorEncoder[two]);
		//writeDebugStreamLine("two: %d", nMotorEncoder[two]);

		if (joy_1y2!=0)
		{
			//wasmanual=1;
			if (
				(nMotorEncoder[arm] < arm_levels[NLEVELS-1] && joy_1y2 > 0)
			||
			(nMotorEncoder[arm] > arm_levels[0] && joy_1y2 < 0)
			){
				nMotorEncoderTarget[arm]=0;
				motor[arm]=joy_1y2;
			}
			else
				motor[arm]=0;
		}
		if (tophat!=tophat_old)
		{
			for (int ii=0;ii<sizeof(arm_levels)/4;ii++)
			{
				rounddown=ii;
				roundup=ii+1;
				if (arm_levels[ii] < nMotorEncoder[arm] < arm_levels[ii+1])
				{
					break;
				}
			}
			switch (tophat){
				case 0:
					motor[arm]=maxspeed;
					nMotorEncoderTarget[arm]=arm_levels[roundup];
					writeDebugStreamLine("U wrote up   %6d", nMotorEncoder[arm]);
					break;
				case 4:
					motor[arm]=-1*maxspeed;
					nMotorEncoderTarget[arm]=arm_levels[rounddown];
					break;
					writeDebugStreamLine("U wrote down %6d", nMotorEncoder[arm]);
				default:
					motor[arm]=0;
					writeDebugStreamLine("DEFAULT      %6d", nMotorEncoder[arm]);
					break;
			}
		}
		tophat_old=tophat;
	}
}
