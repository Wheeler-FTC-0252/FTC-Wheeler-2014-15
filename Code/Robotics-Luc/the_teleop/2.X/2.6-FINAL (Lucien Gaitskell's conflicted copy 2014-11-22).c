#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          arm,           tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    sarm,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    bottle,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    spinner,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    grabber,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NMOTORS 2
#define NLEVELS 3 // sizeof(arm_levels)/4
#define maxspeed 50 //used for arm motors
#define sec_arm_speed 4 //linked to arm servo speed
int arm_levels[NLEVELS]={0,150,590};
int servo_levels[NLEVELS]={0,150,590};

#include "JoystickDriver.c"

int transfer_J_To_M(int joy,float slope,int dead) // joy = joy input, dead = dead band, slope = max motor output/max joy input - in this case 100/128
{
	int y;
	if (abs(joy)<dead)
		y=0;
	else
		y=slope*((float)joy-(float)dead*sgn(joy));

	return y;
}

void init(){
	//ENCODER SETUPS
	nMotorEncoder[arm]=0;

	//SERVO SETUPS
	//	SERVO SPEEDS
	servoChangeRate[sarm]=sec_arm_speed;
	servoChangeRate[bottle]=sec_arm_speed;
}

void movement(int tophat, int * roundup, int * rounddown){
	if (nMotorEncoder[arm]<arm_levels[1]){//lower than 2nd lowest
		*roundup=1;
		*rounddown=0;
	}
	else if (nMotorEncoder[arm]>arm_levels[NLEVELS-2]){//higher then 2nd highest
		*roundup=NLEVELS-1;
		*rounddown=NLEVELS-2;
	}
	else{//somewhere inbetween 2nd low and 2nd high
		for (int ii=0; ii<NLEVELS-1; ii++)
		{
			*roundup=ii+1;
			*rounddown=ii;
			if (arm_levels[*rounddown]<nMotorEncoder[arm] && nMotorEncoder[arm]<arm_levels[*rounddown])
			{
				break;
			}
		}
	}
	writeDebugStreamLine("En: %d, Roundup: %d, Rounddown: %d",nMotorEncoder[arm],*roundup,*rounddown);//nMotorEncoderTarget[arm]);
	switch (tophat){
	case 0://up
		motor[arm]=maxspeed;
		while (nMotorEncoder[arm]<arm_levels[*roundup]){
		}
		motor[arm]=0;
		servo[sarm]=servo_levels[*roundup];
		while (servo[sarm]-5>servo_levels[*rounddown] && servo[sarm]+5<sevo_levels[*rounddown]){
				servo[bottle]=servo[sarm];
		}

		break;
	case 4://down
		if (*rounddown==0){
			servo[sarm]=servo_levels[*rounddown];
			while (servo[sarm]-5>servo_levels[*rounddown] && servo[sarm]+5<sevo_levels[*rounddown]){
				servo[bottle]=servo[sarm];
			}
		}
		motor[arm]=-maxspeed;
		while (nMotorEncoder[arm]>arm_levels[*rounddown]){
		}
		motor[arm]=0;
		if (*rounddown!=0){
			servo[sarm]=servo_levels[*rounddown];
			while (servo[sarm]-5>servo_levels[*rounddown] && servo[sarm]+5<sevo_levels[*rounddown]){
				servo[bottle]=servo[sarm];
			}
		}
		break;
	}
}

task main()
{
	clearDebugStream();
	int joy_1x1;
	int joy_1x2;
	int joy_1y1;
	int joy_1y2;
	int tophat;
	int joy_2x1;
  int joy_2x2;
  int joy_2y1;
  int joy_2y2;

	float joyslope = (100./128.)*.5;
	int dband=15;
	int tophat_old=-1;
	int rounddown=0;//the two values to use when
	int roundup=0;
	int grabber_down=false;
	writeDebugStreamLine("MAKE SURE ROBOT IS ON GROUND");
	wait10Msec(200);
	init();//run my initiation function
	waitForStart();
	while (true)
	{
		//wait10Msec(100);
		getJoystickSettings(joystick);
		joy_1y1=transfer_J_To_M(-joystick.joy1_y1, joyslope, dband);
		joy_1y2=transfer_J_To_M(-joystick.joy1_y2, joyslope, dband);
		joy_1x1=transfer_J_To_M(joystick.joy1_x1, joyslope, dband);
		joy_1x2=transfer_J_To_M(joystick.joy1_x2, joyslope, dband);
		tophat=joystick.joy1_TopHat;
		joy_2y1=transfer_J_To_M(-joystick.joy2_y1, joyslope*(float)1/8, dband);
    joy_2y2=transfer_J_To_M(-joystick.joy2_y2, joyslope*(float)1/8, dband);
    joy_2x1=transfer_J_To_M(joystick.joy2_x1, joyslope, dband);
    joy_2x2=transfer_J_To_M(joystick.joy2_x2, joyslope, dband);

		//   writeDebugStreamLine("one: %d, two: %d", nMotorEncoder[one], nMotorEncoder[two]);
		//writeDebugStreamLine("two: %d", nMotorEncoder[two]);

		if (joy_1y2!=0)//teesting for joy being used
		{
			if (
				(nMotorEncoder[arm] < arm_levels[NLEVELS-1] && joy_1y2 > 0)
			||
			(nMotorEncoder[arm] > arm_levels[0] && joy_1y2 < 0)
			){
				nMotorEncoderTarget[arm]=0;
				motor[arm]=joy_1y2;
			}
			else{
				motor[arm]=0;
			}
		}
		else if (tophat!=tophat_old){
			writeDebugStreamLine("that has changed");
			movement(tophat, &roundup, &rounddown);
		}
		tophat_old=tophat;

		//grab goals
		if (joy2Btn(00)==1){
			if (!grabber_down){//is up (!equals to false)
				servo[grabber]=80;//EDIT PLZ
				grabber_down=true;
			}
			else{
				servo[grabber]=0;
				grabber_down=false;
			}
		}
		motor[rightdrive]=joy_2y1;
		motor[leftdrive]=joy_2y2;
	}
}
