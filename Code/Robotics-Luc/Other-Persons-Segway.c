#pragma config(Sensor, S2,     SensorGyro,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//motor[left] is the master and the slave it motor[right]
#include "hitechnic-accelerometer.h"
float SAMPLE_COUNT = 100;




/* PID constans */
float K_TH = 25;
float K_TH_D = 0.23;
float K_Y = 272.8;
float K_Y_D = 24.6;
float KP = 0.0336;
float KI = 0.2688;
float KD = 0.000504;
float dt = 0.010; // Used in all calculations and events

/* Gyro */
float gyro_angle = 0; // Angle
float gyro_angle_pre = 0; // Angle before filter
float gyro_rate = 0; // Angular velocity
float gyro_offset = 0; // Initial offset

/* misc */
const float wheel_radius = 0.021; // Meaning of life

/* Motor */
float y_ref = 0; // Reference point we want to achieve
float v = 0; // Motor velocity we want to achieve
float y = 0; // Actual motor position
float y_d = 0; // Actual motor velocity
float y_old = 0;


//Timers Used: T1 (change Rate),
void init(){
	//Motors//
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;//the same as the master (100%)
}

float gyroCalibrate(){
	float temp_offset = 0;
	nxtDisplayCenteredTextLine(2, "Hold still...");
	wait1Msec(1000);
	for(int i = 0; i < SAMPLE_COUNT; i++){
		temp_offset = temp_offset + SensorRaw[SensorGyro];
		wait1Msec(10);
	}
	temp_offset = temp_offset / SAMPLE_COUNT;
	eraseDisplay();
	nxtDisplayCenteredTextLine(2, "We're ready!");
	nxtDisplayCenteredTextLine(4, "Get ready in 1 sec");
	wait1Msec(1000);
	return temp_offset; // Calculate offset
}

task main()
{
	int accelOffSet = -600;
	int multiplyer = 100;
	float delta;
	int x;
//	int y;
//	int z;
	int motorOutput;
	int e;
	int motor_power;
	int pid;

	init();
	// ClearTimer(T1);

	gyro_offset=gyroCalibrate();

	while (true){
		//wait1Msec(1);
		//HTACreadAllAxes(accel, x, y, z);
		gyro_rate = SensorValue[SensorGyro];
		gyro_rate = (gyro_rate + SensorValue[SensorGyro]) / 2 - gyro_offset;
		gyro_offset = gyro_offset * 0.999 + (0.001 * (gyro_rate + gyro_offset));
		gyro_angle = gyro_angle + gyro_rate * dt;

		if(0){
			nxtDisplayCenteredTextLine(2,"delta: %f",delta);
			nxtDisplayCenteredTextLine(5,"motorOutput: %d",motorOutput);
			nxtDisplayCenteredTextLine(6,"value: %d",x);
		}

		e = (K_TH * gyro_angle + K_TH_D * gyro_rate + K_Y * y + K_Y_D * y_d);

		pid = (KP * e) / wheel_radius;

		nxtDisplayCenteredBigTextLine(3,"of: %d",gyro_offset);

		motor_power = pid;

		if(motor_power > 100){
      motor_power = 100;
    } else if(motor_power < -100){
      motor_power = -100;
    }
		motor[left] = motor_power;

		wait1Msec(dt*1000)
	}

}
