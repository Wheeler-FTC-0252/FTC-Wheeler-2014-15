#pragma config(Sensor, S1,     accel,          sensorI2CCustom)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 150301 Version - begining to work, but still not stable
//

#include "hitechnic-accelerometer.h"



//USER DEFINED//
float timeWait=0.1; //seconds
float gyroMix=.98; // a percentage (/100.)
int gain=25;
int offsetLoopNumber=100;

task main()
{
	//System Setup
	bPlaySounds = true;
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;


	int gyroAngle=0;
	float accelAngle=0; // + value is bent forward, - value is backwards
	int x;
	int y;
	int z;
	int gyroValue;
	int gyroOffset=0;
	int motorOutput;

	playSound(soundDownwardTones);
	nxtDisplayCenteredTextLine(3,"PLACE THE SEGWAY ON THE FLOOR!");
	wait1Msec(2000);

	for (int ii=0; ii<offsetLoopNumber; ii++){
		gyroOffset=gyroOffset+SensorValue[gyro];
	}
	gyroOffset=round((float)gyroOffset/(float)offsetLoopNumber);
	while(bSoundActive){}//just incase the wait is too short

	nxtDisplayCenteredTextLine(3,"PLEASE START UPRIGHT!");
	playSound(soundUpwardTones);
	wait1Msec(4000);
	while(bSoundActive){}//just incase the wait is too short
	eraseDisplay();
	PlaySound(soundBlip);

	while (true){
		wait1Msec(timeWait*1000);
		gyroValue=SensorValue[gyro]-gyroOffset;
		HTACreadAllAxes(accel, x, y, z);
		gyroAngle=gyroAngle+gyroValue*timeWait;
		accelAngle=-1*atan2((float)x,(float)z);
		accelAngle=accelAngle*180./PI;// rad to degrees
		motorOutput=round(gyroMix*gyroAngle+((float)1-gyroMix)*accelAngle)*gain;
		//writeDebugStreamLine("GYRO: %d, x: %d, z: %d, ACCEL: %f, output: %d", gyroAngle, x, z, accelAngle, motorOutput)
		nxtDisplayCenteredTextLine(1,"GYRO: %d",gyroAngle);
		nxtDisplayCenteredTextLine(3,"x: %d, z: %d",x,z);
		nxtDisplayCenteredTextLine(5,"ACCEL: %f",accelAngle);
		nxtDisplayCenteredTextLine(7,"motorOutput: %d",motorOutput);
		motor[motorA]=motorOutput;
	}
}
