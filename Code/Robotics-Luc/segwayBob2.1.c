#pragma config(Sensor, S1,     accel,          sensorI2CCustom)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 150301 Version - begining to work, but still not stable
// 150301 v2.1 - Looking at feedback


#include "hitechnic-accelerometer.h"



//USER DEFINED//
float timeWait=0.01; //seconds, 10 ms / 100 Hz looping - was taking t
float gyroMix=0.98; // Fraction of gyroRate-based integrated data versus Accelerometer Angle data used for absolute angle
int pGain = 25; // gain for the "P" factor
int iGain = 25; // gain for the "I" factor
int dGain = 25; // gain for the "D" factor
int offsetLoopNumber=100; // Number of measurements to get average gyro value for no rotation
int integDecay = 500; // how many loops after a value is added is 30% of the origional - "I"

task main()
{
	//System Setup
	bPlaySounds = true;
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;


	float gyroAngle=0.; // Estimate of angle of Bob, +ve is forward
	float accelAngle=0.; // + value is bent forward, - value is backwards
	int x,y,z;
	float gyroRateValue; // gyro rate degrees/second
	float gyroRateOffset = 0.;
	int motorOutput;
	float integration = 0;
	float differential;
	playSound(soundDownwardTones);
	nxtDisplayCenteredTextLine(3,"PLACE THE SEGWAY ON THE FLOOR!");
	wait1Msec(2000);

	// CALCULATE THE AVERAGE OFFSET FOR STATIONARY (NO ROTATION)
	for (int ii=0; ii<offsetLoopNumber; ii++){
		gyroRateOffset = gyroRateOffset + (float)SensorValue[gyro];
	}
	gyroRateOffset = round( gyroRateOffset/(float)offsetLoopNumber );
	while(bSoundActive){}//just incase the wait is too short

	nxtDisplayCenteredTextLine(3,"PLEASE START UPRIGHT!");
	playSound(soundUpwardTones);
	wait1Msec(4000);
	while(bSoundActive){}//just incase the wait is too short


	// Start the main control loop
	eraseDisplay();
	playSound(soundBlip);

	int loopCount = 0; // Count loop iterations (first loop - is zero)
	while (true){
		// Time for loop control
		clearTimer(T1);

		gyroRateValue = (float)SensorValue[gyro] - gyroRateOffset; // Read the GYRO
		HTACreadAllAxes(accel, x, y, z); // Read the ACCELEROMETER

		//---- Sensor Readings and "P"----
		// ACCELEROMETER estimated - low sensitivity, but maintains absolute calibration without drift
		accelAngle = 180./PI * (-1*atan2((float)x,(float)z)); // Accelerometer angle, includes rad to degrees, +ve angle is leaning forward

		// Gyro absolute angle [degrees] based on integrating gyroRate, mixed with small amount of abslute value from accelerometer
		gyroAngle = ( gyroMix * (gyroAngle + gyroRateValue*timeWait) ) + ((1.-gyroMix)*accelAngle);

		//---- "I" ----
		integration = gyroAngle + (float)(integDecay-1)/(float)integDecay*(float)integration;

		//---- "D" ----
		differential = gyroAngle;

		motorOutput=round( (float)pGain * gyroAngle + (float)iGain * integration + (float)dGain * differential );
		motor[motorA]=motorOutput;

		// DISPLAY
		if( loopCount%100 == 0) 			// Display values every n'th loops
		{
			//writeDebugStreamLine("GYRO: %d, x: %d, z: %d, ACCEL: %f, output: %d", gyroAngle, x, z, accelAngle, motorOutput)
			nxtDisplayCenteredTextLine(1,"GYRO: %6.1f",gyroAngle);
			//nxtDisplayCenteredTextLine(3,"x: %d, z: %d",x,z);
			nxtDisplayCenteredTextLine(3,"loop: %d", loopCount);
			nxtDisplayCenteredTextLine(5,"ACCEL: %6.1f",accelAngle);
			nxtDisplayCenteredTextLine(7,"motorOutput: %d",motorOutput);
		}

		// LOOP CONTROL
		loopCount++;

		while(time1[T1]<timeWait/2*1000){}
		//wait1Msec(timeWait/2*1000); // Wait before looping again - need to manually adjust
	}
}
