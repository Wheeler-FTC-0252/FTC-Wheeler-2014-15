
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     rightmotor1,   tmotorTetrix, PIDControl, reversed, driveRight)
#pragma config(Motor,  mtr_S1_C2_2,     rightmotor2,   tmotorTetrix, PIDControl, reversed, driveRight)
#pragma config(Motor,  mtr_S1_C3_1,     leftmotor1,    tmotorTetrix, PIDControl, driveLeft)
#pragma config(Motor,  mtr_S1_C3_2,     leftmotor2,    tmotorTetrix, PIDControl, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
task main()
{
	/*Motor map:

	Motor Controller 1 = arm motors(not called in)
	Motor Controller 2 = left motor 1 & 2, spliced
	                     left motor 3
	Motor Controller 3 = right motor 1 & 2, spliced
	                     right motor 3*/

	int threshold = 10;
	while (true)
	{
		getJoystickSettings(joystick);

		if(abs(joystick.joy1_y1) > threshold)
    {
      motor[leftmotor1] = joystick.joy1_y1/10;
      motor[leftmotor2] = joystick.joy1_y1/10;
    }
    else
    {
      motor[leftmotor1] = 0;
      motor[leftmotor2] = 0;
    }

    if(abs(joystick.joy1_y2) > threshold)
    {
      motor[rightmotor1] = joystick.joy1_y2/10;
      motor[rightmotor2] = joystick.joy1_y2/10;
    }
    else
    {
      motor[rightmotor1] = 0;
      motor[rightmotor2] = 0;
    }
  }




}
